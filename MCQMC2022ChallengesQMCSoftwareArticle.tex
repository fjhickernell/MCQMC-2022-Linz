% MCQMC 2022 article on the Challenges of Great MCQMC Software
%
% sample root file for your "contribution" to a contributed volume
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% author.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample root file for your "contribution" to a contributed volume
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% RECOMMENDED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[graybox]{svmult}

% choose options for [] as required from the list
% in the Reference Guide

\usepackage{type1cm}        % activate if the above 3 fonts are
% not available on your system
%
\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
% when including figure files
\usepackage{multicol}        % used for the two-column index
\usepackage[bottom]{footmisc}% places footnotes at page bottom
\usepackage{epstopdf,psfrag}

\usepackage{newtxtext}       %
\usepackage[varvw]{newtxmath}       % selects Times Roman as basic font

% see the list of further useful packages
% in the Reference Guide

%\makeindex             % used for the subject index
% please use the style svind.ist with
% your makeindex program

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%Fred start
\input{common-macros.tex}
\usepackage{cite}
\usepackage{xspace}
\usepackage[hyphens]{url}
\providecommand{\HickernellFJ}{Hickernell\xspace}
\graphicspath{{ProgramsImages/}}

%\input FJHDef.tex
\newcommand{\AGSComment}[1]{{\color{red} #1}}
\newcommand{\FredComment}[1]{{\color{blue} Fred: #1}}
\newcommand{\SCComment}[1]{{\color{green} Sou-Cheng: #1}}
\newcommand{\YDComment}[1]{{\color{orange} Yuhan: #1}}
\newcommand{\JagsComment}[1]{{\color{violet} Jags: #1}}
\DeclareMathOperator{\disc}{disc}
\newcommand{\FJHNote}[1]{{\color{blue}Fred: #1}}

%%%%Fred end

\begin{document}

\title*{Challenges in Developing Great Quasi-Monte Carlo Software}
\authorrunning{S.-C.\ T.\ Choi et al.}
\author{Sou-Cheng T.~Choi \and Yuhan Ding \and Fred J. Hickernell \and Jagadeeswaran  Rathinavel \and Aleksei G. Sorokin}
\institute{
Sou-Cheng T.~Choi \at Department of Applied Mathematics, Illinois Institute of Technology,\\ RE 220, 10 W.\ 32$^{\text{nd}}$ St., Chicago, IL 60616 \email{schoi32@iit.edu}
\and
Yuhan Ding \at
 Department of Applied Mathematics, Illinois Institute of Technology,\\ RE 220, 10 W.\ 32$^{\text{nd}}$ St., Chicago, IL 60616 \email{yding2@hawk.iit.edu}
\and
Fred J. Hickernell \at Center for Interdisciplinary Scientific Computation and \\
Department of Applied Mathematics, Illinois Institute of Technology \\ RE 220, 10 W.\ 32$^{\text{nd}}$ St., Chicago, IL 60616 \email{hickernell@iit.edu}
\and
Jagadeeswaran  Rathinavel \at
Department of Applied Mathematics, Illinois Institute of Technology,\\ RE 220, 10 W.\ 32$^{\text{nd}}$ St., Chicago, IL 60616 \email{jrathin1@hawk.iit.edu}
\and
Aleksei G. Sorokin \at
Department of Applied Mathematics, Illinois Institute of Technology,\\ RE 220, 10 W.\ 32$^{\text{nd}}$ St., Chicago, IL 60616 \email{asorokin@hawk.iit.edu}}

\maketitle

\abstract{
Quasi-Monte Carlo (QMC) methods have developed over several decades. With the explosion in computational science, there is a need for great software that implements QMC algorithms. We summarize the  QMC software that has been developed to date, propose some criteria for developing great QMC software, and suggest some steps toward achieving great software. \SCComment{We demonstrate these criteria and steps in practice with Quasi-Monte Carlo Python library (QMCPy), an open-source community software framework, extensible by design with common programming interfaces to an increasing number of existing or emerging QMC libraries developed by the greater community of QMC researchers.}
}


\section{Introduction}

A QMC approximation of $\mu := \EE[f(\bsX)]$, $\bsX \sim \calU[0,1]^d$ can be implemented in a few steps:
\begin{enumerate}
    \item Draw a sequence of $n$ low-discrepancy (LD) \cite{Nie92, SloJoe94, DicEtal14a, DicEtal22a} nodes,
    $\bsx_1,\dots,\bsx_n$ that mimic $\calU[0,1]^d$.
    \item Evaluate the integrand $f$ at these nodes to obtain $f(\bsx_i)$, $i=1,\dots,n$.
    \item Estimate the true mean, $\mu$, by the sample mean,
    \begin{equation}
        \hat{\mu_n} := \frac{1}{n} \sum_{i=1}^n f(\bsx_i).
        \label{eq:mc_average}
    \end{equation}
\end{enumerate}
However, the practice of QMC is often more complicated.  The original problem may need to be rewritten to fit the above form and/or to facilitate a good approximation with a small number of sampling points, $n$.  Practitioners may wish to determine $n$ adaptively to satisfy a prescribed error tolerance.

In the next section, we describe why QMC software is important.  We then discuss the characteristics of great QMC software:

\begin{itemize}
\item Integrated with related libraries (Sect.\ \ref{CDHJS_sec:integrated}),

\item Correct (Sect.\ \ref{CDHJS_sec:correct}),

\item Efficient in computational time and memory (Sect.\ \ref{CDHJS_sec:efficient}),

\item Accessible to practitioners and theorists alike (Sect.\ \ref{CDHJS_sec:accessible}), and

\item Sustainable by a community that owns it (Sect.\ \ref{CDHJS_sec:sustainable}).

\end{itemize}
In each section, we describe the challenges faced and how they might be overcome.

We draw on our collective experiences as
members of the academic QMC community, developers of open-source and commercial scientific software, and users of a wide range of scientific software as research scientists or data scientists. Many of the insights that we have gained have come through our development of the Guaranteed Automatic Integration Library (GAIL)~\cite{ChoEtal22a} in MATLAB and the Quasi-Monte Carlo Python library (QMCPy)~ \cite{QMCPy2020a}.   \FJHNote{Sou-Cheng, not sure what this means.} \SCComment{Fred, more elaboration here, but maybe it fits better in Section 3: In particular, QMCPy is not just a QMC software containing our own algorithms; from the outset, it is designed to serve as a middleware framework, allowing users to tap into a collection of QMC libraries originally written in various languages by different researchers at different times. Using object-oriented design, QMCPy specifies a few  extensible high-level mathematical objects essential in multiple integration (see Sect.\ \ref{CDHJS_sec:integrated}). Developers of other (Q)MC software could easily extend these objects to incorporate their existing or working algorithms by a combination of mechanism: object inheritance; Python package inclusion; direct code translation; interfaces to compiled C or Java libraries. Hence QMCPy has been able to provide access to an increasing number of well-established (Q)MC algorithmic or application software.}

\section{Why Develop QMC Software} \label{CDHJS_sec:why_we_need_software}

Recent interest in quality scientific software is exemplified by the 2021 US Department of Energy report, \emph{Workshop on the Science of Scientific-Software Development and Use} \cite{ASCR-SSSDU, osti_1846008}. This workshop not only discussed diagnostics and treatments for the challenges of developing great scientific software, but also emphasized the importance of implementing theoretical advancements into well-written, accessible software libraries. Three cross-cutting themes arose in this workshop:
\begin{itemize}
    \item  We need to consider both human and technical elements to better understand how to improve the development and use of scientific software.

    \item We need to address urgent challenges in workforce recruitment and retention in the computing sciences with growth through expanded diversity, stable career paths, and the creation of a community and culture that attract and retain new generations of scientists.

    \item Scientific software has become essential to all areas of science and technology, creating opportunities for expanded partnerships, collaboration, and impact.
\end{itemize}
These themes apply to QMC software in particular, as well as scientific software in general.

\subsection{QMC Theory to Software}

QMC software makes theoretical advances in QMC available to practitioners. However, translating pseudo-code into good executable code is nuanced.  Software developers must write code that is computationally efficient, numerically stable, and provides reasonable default choices of tuning parameters. Great QMC software relieves users of these concerns.

\subsection{QMC Software to Theory}

Great QMC software opens up new application areas for QMC methods by allowing practitioners to compare new methods to existing ones.  QMC software has been successful in quantitative finance, uncertainty quantification, and image rendering. Unexpectedly good or bad computational results lead to open theoretical questions.  For example, the early application of QMC to high dimensional integrals arising in financial risk \cite{PasTra95} led to a wave of theoretical results on the tractability of integration in weighted spaces \cite{Woz99a,DicEtal14a,NovWoz10a}.

Great QMC software eliminates the need for researchers to resort to  ``do-it-yourself'' for established algorithms.  The less code we have to write, the fewer errors. \AGSComment{Aleksei: Put in previous subsection.}

We next discuss the characteristics of great QMC software outlined in the introduction.  For each characteristic, we identify what is lacking and what might be done to remedy the lack.

\section{Integrated} \label{CDHJS_sec:integrated}

Expanding on the problem formulation in the introduction, we want to approximate well the integral or expectation, $\mu$, by the sample mean, $\hat{\mu_n}$:
\begin{gather}
\label{eq:cubSummary}
	\mu : = \int_\calT g(\bst) \, \lambda(\bst) \, \D \bst  = \bbE[f(\bsX)] = \int_{[0,1]^d} f(\bsx)  \, \D \bsx \approx \frac 1n \sum_{i=1}^{n} f(\bsx_i) =: \hat{\mu}_n, \\
 \label{CDHJS_eq:error_tol}
 \abs{\mu - \hat{\mu}_n} \le \varepsilon.
\end{gather}
Progressing from the original problem to a satisfactory solution requires several software components, which we describe in the subsections below.  Great QMC software environments allow different implementations of these components to be freely interchanged.

\subsection{LD Sequence Generators} A lattice, digital sequence, or Halton sequence generator typically supplies the sequence $\bsx_1, \bsx_2, \ldots$.  These sequences may be deterministic or random and are intended to have an empirical distribution that approximates well the uniform distribution.

LD generators are the most prevalent, generally available components of QMC software.  These generators appear in Association of Computing Machinery  publications \cite{BraFox88,BraFoxNie92,HonHic00a}, FinDer \cite{PasTra95,FinDer}, libseq \cite{FriKel02,FriKelweb}, BRODA \cite{BRODA20a}, NAG \cite{NAG27}, MATLAB \cite{MAT9.13}, SamplePack \cite{SamplePack}, Gr\"unschlo{\ss}'s website \cite{GruWeb}, the Magic Point Shop \cite{NuyWeb}, R \cite{QRNG2020}, Julia \cite{QMCJulia}, PyTorch \cite{paszke2019pytorch}, SAS \cite{SAS_LD}, SciPy \cite{virtanen2020scipy},  TensorFlow \cite{tfqfQMC2021a}, MatBuilder \cite{paulin2022}, and  QMCPy \cite{QMCPy2020a}.

Lattice and digital sequences are not unique, and improved or alternate versions continue to be constructed.  Stephen Joe and Frances Kuo \cite{JoeKuo03,JoeKuo08,SobolDirection} have proposed  Sobol' generator direction numbers, which are now widely used, but were not part of early LD sequence software.  Pierre L'Ecuyer and collaborators have created LatNetBuilder \cite{LatNet} to construct good lattice and polynomial lattice sequences based on user-defined criteria. During a lunch at MCQMC 2022, it was proposed that we  agree on a consistent format for storing the parameters that define good LD sequences so that they can be shared across software libraries.

Users computing solutions in comprehensive software environments, such as NAG, MATLAB, R, SciPy, and TensorFlow, have convenient access to LD sequence generators.  However, most of these implementations in large libraries could provide more flexible \SCComment{what does more flexible mean?} LD offerings.  Some large environments such as  Dakota \cite{DakotaUsersManual} have quite limited LD generators and should expand their offerings. \SCComment{Other established software such as SAS expand offerings of trustworthy and efficient analytics through continuous internal implementation as well as flexible integration of third-party open-source software; see \url{https://www.sas.com/en_us/software/viya/open.html}. Such a latter software development strategy presents opportunities for}  developers of smaller libraries with more QMC features, like BRODA and QMCPy, to demonstrate how their libraries can connect well with other software environments.  An example of QMCPy connecting with other software is given in the next subsection.

\subsection{Integrands and Variable Transformations} \label{CDHJS:sec:integrands}
The original integral or expectation arising from an application is defined in terms of the integrand, $g$, and the non-negative weight, $\lambda$.  For example,
\begin{itemize}
	\item $g$ is the discounted payoff of a financial derivative and $\lambda$ is the probability density function (PDF) for a discretized Brownian motion \cite{Gla03},

	\item  $g$ is the velocity of a fluid at a point in rock with a random porosity field whose discretized PDF is $\lambda$ \cite{KuoNuy16a}, or

	\item $g\lambda$ is the unnormalized Bayesian posterior density multiplied by parameter of interest \cite{GelEtal13}.
\end{itemize}

To put $\mu$ into the form that is directly accessible to QMC methods requires a variable transformation, $\bsPsi$, such that
\begin{equation*}
    \bsPsi((0,1)^d) = \calT, \qquad f(\bsx) = g(\bsPsi(\bsx)) \lambda(\bsPsi(\bsx)) \abs{\frac{\partial \bsPsi}{\partial\bsx}}.
\end{equation*}
Such a transformation is typically non-unique, and the choice of a good one is equivalent to importance sampling.  If $\lambda$ is a PDF for a random variable $\bsT$, then $\mu = \EE[g(\bsT)]$.  In this case, one might choose $\bsPsi$ such that $\bsT \sim \bsPsi(\bsX)$, in which case $\lambda(\bsPsi(\bsx)) \abs{\partial \bsPsi/\partial\bsx} = 1$ and $f(\bsx) = g(\bsPsi(\bsx))$. \AGSComment{Aleksei: Software such as SciPy and QMCPy facilitate such variable transformations by providing default $\bsPsi$ for common $\bsT$. This alleviates the burden on the user to determine a transformation and implement the Jacobian. }

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{cantileveredbeamwords.eps}
    \includegraphics[width=0.7\textwidth]{ldparallelbeam.eps}
    \caption{The expected deflection of a cantilevered beam with random Young's modulus.  QMCPy computes the answer in serial and in parallel using UM-Bridge and docker containers.  For small error tolerances, the time and sample size is $\calO(\varepsilon^{-1})$, and parallel processing gives a speed-up factor of four to five. These plots may be reproduced using the Jupyter notebook \SCComment{(1) Add url or citation. (2) What is the meaning of min and sec on the y-axis of lower left graph (The label says (s), which means seconds right?)? Are there numerical values on (left and right) y-axis? (3) The font size of the axis labels for the lower graphs could be made larger more like the top graph. (4) I guess the blue colors are covered by the orange colors in the bottom right graph. Maybe we can use blue crosses and orange broken lines instead.}}
    \label{fig:beam}
\end{figure}

Complex integrands might be best evaluated by libraries that have no direct connection to QMC software libraries.  In the uncertainty quantification (UQ) space, the recently developed UQ and Model Bridge (UM-Bridge) \cite{umbridge}, connects libraries that generate sequences of model parameters, $\bsx_1, \bsx_2, \ldots$ with libraries that evaluate models, $f(\bsx_1), f(\bsx_2), \ldots$.  We illustrate in Figure \ref{fig:beam} how UM-Bridge connects QMCPy with a differential equation boundary value problem solver for a cantilevered beam with random Young's modulus \cite{ParSee22a}, where the randomness is given by $\bsX \sim \calU[1,1.2]^3$.  The beam position is discretized at $31$ points.  QMCPy computes the expected deflection of the beam at these points for a sequence of error tolerances using lattice rules.  By taking advantage of virtual machines and docker containers, UM-Bridge provides automatic load balancing to facilitate seamless parallel model evaluation.% the evaluation of the beam deflection can be computed in parallel in multiple cores of a single CPU to decrease execution time.

We need more connections of QMC software to other libraries, like what has been done with  QMCPy and UM-Bridge.  This will allow newer and better QMC algorithms to tackle new applications.

\subsection{Stopping Criteria}
The cantilevered beam example illustrated in Figure \ref{fig:beam} utilizes QMCPy's stopping criterion to choose the sample size, $n$, based on the input error tolerance, $\varepsilon$, and the observed discrete Fourier series coefficients of the integrand, $f$.  See \cite{HicJim16a} for details of this stopping criterion for lattice rules and \cite{HicEtal18a} for a review on automatic QMC stopping criteria.  Theoretically justified stopping criteria for choosing sample sizes are important and a relatively recent development \cite{HicEtal14a,HicJim16a,JimHic16a,RatHic19a,JagHic22a}.  Some of these stopping criteria for absolute error criteria, \eqref{CDHJS_eq:error_tol},  have been extended to relative error criteria or a combination of absolute and relative error criteria, as well as stopping criteria for approximating functions of several integrals \cite{Jia16a,GilJim16b,HicEtal17a,JagSor23a}.

We emphasize again that no one software library contains all of the best LD generators, integrands, variable transformations, and stopping criteria, which is why great QMC software must be well integrated into other software libraries.  This may take the form of large libraries incorporating more QMC routines and/or building connections among QMC libraries and with other non-QMC libraries.


\section{Correct} \label{CDHJS_sec:correct}
Although correctness is an obvious feature of great QMC software, it should not always be assumed in popular packages.  Here are two examples.

MATLAB's original randomization of Sobol' points was incorrectly implemented.  This was discovered by Llu\'is Antoni Jim\'enez Rugama, who informed the developer.  The error was corrected in MATLAB R2018a.

SciPy and PyTorch's original implementations of Sobol' sequences omitted the first point.  The rationale was that the unscrambled first point of the Sobol' sequence is $\bsx_1 = \bszero$, which becomes the undesirable $\boldsymbol{-\infty}$ when transformed to mimic a Gaussian distribution.  A vigorous discussion ensued \cite{scipySobol2020a,pytorchSoboldiscussion2020a}, which prompted an article by Art Owen \cite{Owe22a} on why one should not drop the first point and destroy the digital net structure.  Instead one should randomly scramble the Sobol' sequence (and other LD sequences) so that $\bsx_1 \ne \bszero$.  Although SciPy and PyTorch were corrected, other software libraries with LD sequence generators still omit the first point.

QMC software is sometimes written by those not intimately familiar with QMC.  Those of us most familiar with good QMC practices need to pay attention to QMC algorithms in popular software libraries and inform the developers when their software contains bugs or deviates from best practices.

\section{Efficient} \label{CDHJS_sec:efficient}
Another obvious feature of great QMC software is numerical efficiency.  This requires developers to identify bottlenecks in performance.  Intensive computations may need to be rewritten in lower-level languages, like C.  Code may need to be refactored to avoid excessive calls to memory.  As new hardware architectures arise, QMC software should adapt to take advantage of them.

Efficiency gains in QMC software can also result from clever algorithm choices.  The Bayesian stopping rules for lattice and Sobol sequences in \cite{RatHic19a,JagHic22a} choose covariance kernels that match the corresponding LD sequence.  This reduces the computations from what would be $\calO(n^3)$ for arbitrary covariance kernels to only $\calO(n \log n)$ for these well-chosen kernels. Consequently, computing the stopping criterion is roughly the same order of magnitude as computing the solution.

In spite of the desire for efficiency, great QMC software will be written in a variety of computer languages since different communities tend to favor different languages. Trade-offs will be made between efficiency and convenience.

\section{Accessible} \label{CDHJS_sec:accessible}
One attribute of great QMC software that often receives insufficient attention is its accessibility.  Developers may write code for their own purposes and move on.

Great software should be stored in a repository, where the latest version can be downloaded.  There should be documentation that guides the user through installation and explains the library's features.  Demos are crucial for showing how the software works and for providing a template for new users to write their own code.  Tutorials help newcomers to QMC understand its advantages. Blogs educate a wider audience and enlarge our QMC community.  A suite of unit tests should be run regularly to ensure that new features do not introduce bugs. There should be a place for users to report bugs and make feature requests.

Accessible QMC software has greater impact.  Accessibility also depends on the next characteristic of great QMC software.


\section{Sustainable} \label{CDHJS_sec:sustainable}
Great QMC software libraries should be alive.  They should be under active development or merged into other libraries that are actively maintained.  Commercial software has an infrastructure to maintain their algorithms, but these algorithms need periodic refreshing. Open source software requires a community of active users and developers to keep the library up-to-date and bug-free. 

The QMC community can help sustain great QMC software in several ways.  \begin{itemize}
	\item Let's build our research code and showcase our new algorithms using existing QMC software libraries or build and maintain new libraries, if needed.  This allows the next generation to more easily reproduce our results and build upon them.

	\item Many of us QMC researchers rely on transient team members (students and postdocs) to write the code that illustrates our new ideas.  Building our own QMC libraries or contributing to existing ones helps ensure that the code our team members write lasts beyond their involvement in our teams.

	\item It is relatively easy to post demos of our new ideas on our own web pages, and if possible in the software libraries that we are using.  QMCPy welcomes blogs, short articles introducing a broader audience to important ideas, illustrated by software.

	\item When we see bugs or missing features in QMC software, let's persistently request fixes and improvements.  The more robust our QMC software, the easier it is to open new application areas to QMC and grow our QMC community.

    \item \SCComment{Let's publish our QMC  software with journals such as ACM TOMS, JORS, etc. to obtain code review and
    feedback.}
    
    \item \SCComment{When we find QMC scientific software useful in our research or applications, let's encourage and recognize such software by giving them proper citations~\cite{smith2016software}. }

    \item \SCComment{Encourage QMC community members to learn about software development through interdisciplinary education, internship, or hackathon. }

\end{itemize}


Encouraging students and postdocs to invest time in developing QMC software will require us as their mentors valuing software as a research output.  Great software should be published with a digital object identifier (DOI).  \SCComment{The previous sentence is about publishing software. The next point is about a career path.}  The term research software engineer (RSE) is becoming a more valued vocation.  According to the website for  Research Software Engineers International, \url{https://researchsoftware.org}, \emph{Research Software Engineers are people who combine professional software expertise with an understanding of research.}



\section{Summary}
QMC has experienced decades of exciting growth in theory since the late 1950s.  The earliest publicly available QMC software dates to the early 1990s and its growth has not matched that of theory.  As a QMC community, we have a responsibility to implement our great theory into great QMC software.

\SCComment{Change `sobol' to `Sobol' in reference items 29 and 30. Change `scipy' to `SciPy' in 44 and 45. }
\bibliographystyle{spmpsci}
\bibliography{FJH23,FJHown23,sc}


\end{document}





\section{Tenets of Great Software} \label{CDHJS_sec:tenets_of_great_software}

In this section we lay out common aspirations of scientific software. While some objectives are expected by practitioners, e.g. correctly written software, others may better be characterized as features that are pursued as a project matures, e.g. supporting scalable computation. The following paragraphs highlight aspirations with more important, expected behaviours coming earlier in the discussion.

Software is expected to be \emph{correct}. A practitioner generating a digital sequence expects the routine to produce theoretically accurate points. For example, the QMC community has helped developers ensure implementations of low discrepancy sequence generators include the zeroth point \cite{Owe22a, scipySobol2020a} and  have correct randomization routines. %, and disallow thinning / leaping: taking every $k^\text{th}$ value in the sequence.

Algorithms should be implemented in an \emph{efficient} manner. Both the compute time and memory requirements should match theoretical developments which in turn should be as close to the state of the art as possible. As a classical example, it is expected that an implementation of the discrete Fourier transform for $n$ points has complexity $\mathcal{O}(n\log n)$.

Software should be \emph{accessible} in terms of installation, presentation, navigation, exemplification, and communication. A library should be straightforward to install from a common distribution platform, consistent in user interface, intuitive to navigate to modules and documentation, comprehensible in its' examples, and supportive in user engagement. Software accessibility considerations are further discussed in Sect.\ \ref{CDHJS_sec:language_library_environment}.

Libraries should be \emph{sustainable} for future development. The goal should be to have a sufficient user base and developer community for updates and maintenance. Similar to accessibility, sustainability is often overlooked for aspirations discussed later in this section. However, we contend that a sub-optimal but user-friendly library with community engagement may be more impactful than an optimal library which lacks support. We promote collaborative, community driven development further in Sect.\ \ref{CDHJS_sec:encouraging_collaborative_developement}.

Software should be \emph{integrated} into the environment's scientific software ecosystem. More simply, libraries should play nicely together and utilize the mature developments of other teams. A simple example in \AGSComment{CITE} shows a straightforward integration between the QMC package QMCPy \cite{QMCPy2020a} and the PDE package FEniCS/Dolfin \cite{LoggEtal_10_2012}, both in Python.

Routines should be \emph{scalable} to advanced computer architectures. The widespread availability of on demand computing with multi-core and multi-GPU machines encourages software that can take advantage of parallel computation. Scalable algorithms lend themselves to a larger class or problems and provide practitioners the opportunity to more quickly test ideas.

\section{(Quasi-)Monte Carlo Software Architecture} \label{CDHJS_sec:qmc_software_architecture}

An important step in the development of any software is to determine its' architecture. How should components interact with each other? Which aspects should be modular? Object oriented? Procedural? Answers to these questions form the blueprint of software design and guide implementation.

This section proposes an object oriented design for (Q)MC software. The authors have implemented this architecture into the QMCPy \cite{QMCPy2020a} Python package which is further detailed in the MCQMC 2020 proceedings article \AGSComment{CITE}. While this is not the only possible architecture for (Q)MC problems, we hope the high level object definitions facilitate easy collaboration and integration for research across the (Q)MC community.

The standard (Q)MC problem is to approximate the true mean $\mu := \mathbb{E}[g(\boldsymbol{T})]$ where $\boldsymbol{T}$ is some $d$ dimensional random variable. For nice $\boldsymbol{T}$, one may perform a change of variables to write $\mu = \mathbb{E}[f(\boldsymbol{X})]$ where $\boldsymbol{X} \sim \mathcal{U}[0,1]^d$. For example, if $\boldsymbol{T} \sim \mathcal{N}(\boldsymbol{0},\boldsymbol{I})$, then one may set $f(\boldsymbol{x}) := g(\boldsymbol{\Phi}^{-1}(\boldsymbol{x}))$ for $\boldsymbol{x} \in [0,1]^d$ where $\boldsymbol{\Phi}^{-1}$ is the inverse CDF of a standard normal distribution taken element wise. One may then approximate $\mu$ by the $n$ sample average $\hat{\mu} = 1/n \sum_{i=1}^n f(\boldsymbol{x}_i)$ where $\{\boldsymbol{x}_i\}_{i=1}^n$ are chosen so their empirical distribution is ``close'' to the uniform distribution. The approximation error $\varepsilon = \lvert \mu - \hat{\mu} \rvert$ is $\mathcal{O}(n^{-1/2})$ when $\{\boldsymbol{x}_i\}_{i=1}^n$ are chosen to be IID standard uniform as in the case of simple Monte Carlo (MC) and almost $\mathcal{O}(n^{-1})$ when $\{\boldsymbol{x}_i\}_{i=1}^n$ are chosen from a low discrepancy sequence as done for Quasi-Monte Carlo (QMC). Instead of selecting the number of samples $n$ and then determining the error $\varepsilon$, it is often desirable to select $\varepsilon$ and then adaptively determine $n$. From this view, $n$ is $\mathcal{O}(\varepsilon^{-2})$ for MC and almost $\mathcal{O}(\varepsilon^{-1})$ for QMC. A more detailed account of MC and QMC can be found in \AGSComment{CITE}.

The (Q)MC pipeline above can be decomposed into $4$ main components:
\begin{description}
    \item[\textbf{Generator:}] producing $\{\boldsymbol{x}_i\}_{i=1}^n$ whose empirical distribution is ``close'' to the standard uniform distribution in $d$ dimensions for any $n \geq 1$.  May produce IID or low discrepancy sequences depending on the problem.
    \item[\textbf{Measure:}] that defines the distribution of $\boldsymbol{T}$ e.g., uniform, Gaussian, Lebesgue. This definition facilitates choosing a change of variables to determine $f$.
    \item[\textbf{Integrand:}] $g$, which defines the original integral. When provided knowledge of the true measure, the integrand can also evaluate $f$ via the change of variables.
    \item[\textbf{Stopping Criterion:}] based on a data-driven error bound, which determines how large $n$ should be to ensure that $\varepsilon$ is less than some user-provided error threshold.
\end{description}
A variety of QMC materials and the their categorizations into the above framework are described in the following list.
\begin{itemize}
    %\item \cite{LEc2017a} provides a history of random number generation
    %\item Notorious RANDU from the 1960s \cite{RANDU}, which fails the spectral test
    %\item VEGAS \cite{Lep78a, Lep21a} importance sampling Monte Carlo algorithm favored by physicists
    \item ACM low discrepancy point generators \cite{BraFox88,BraFoxNie92,HonHic00a}
    \item FinDer \cite{PasTra95,FinDer} and BRODA \cite{BRODA20a} targeting quantitative finance
    \item Korobov cubature and scrambled Sobol' generators in NAG \cite{NAG27} for decades
    \item Scrambled Sobol' and Halton generators in MATLAB \cite{MAT9.13} since 2008, and fixed a few years later
    %\item BUGS \cite{BUGSBook, BUGSweb} and Stan \cite{STAN} for Markov Chain Monte Carlo (MCMC)
    \item LatMRG \cite{LEcCou97}, RNGStreams \cite{LEcEtal02},  SSJ \cite{LEc2002a,SSJ}, and LatNetBuilder \cite{LatNet}
    \item Low discrepancy generators \cite{FriKel02,FriKelweb}, SamplePack \cite{SamplePack}, \cite{GruWeb},  and MatBuilder \cite{paulin2022}
    \item Sobol' direction numbers \cite{JoeKuo03,JoeKuo08,SobolDirection}
    \item Fast CBC, Magic Point Shop, QMC4PDE and other code since 2004  at \cite{NuyWeb}
    \item Multi-level software \cite{GilesSoft,GilesQSoft}
    \item Data-driven error bounds and stopping criteria in GAIL \cite{ChoEtal21a} and QMCPy \cite{QMCPy2020a, ChoEtal22a}
    \item Uncertainty quantification libraries Dakota \cite{DakotaUsersManual}, UQTk \cite{DebEtal04,UQTk}, and MUQ \cite{MUQ}  have some basic level low discrepancy sampling
    \item QMC framework in Julia since 2019 \cite{QMCJulia} by Robbe and others
    \item Scrambled Sobol' in SciPy \cite{virtanen2020scipy} and PyTorch \cite{paszke2019pytorch} since several years ago
    \item TensorFlow QMC framework \cite{tfqfQMC2021a} since a year or so ago
    \item CUBA \cite{CUBA}
\end{itemize}

\section{Choosing a Environment} \label{CDHJS_sec:language_library_environment}

This section discusses the challenges in choosing environments for development and distribution. The development environment includes the choice of which languages, architectures, testing methods, and documentation methods to support. The deployment environment will often be influenced by the choice of programming languages.

The choice of programming language should be aligned with the communities the team wishes to reach with their software. The choice should also account for developer familiarity and ability to quickly prototype ideas. A team should align their choice of language to balance the desire to have user-friendly prototyping code versus the desire to have high performance computing (HPC) ``ninja'' code written for production setting. To the second point, it is also important to consider which language will best facilitate the parallel and GPU computations the team wishes to support.

Many programming languages come bundled with their own preferred distribution systems. Python has PyPI, R has CRAN, Julia has Pkg. However, many projects support multiple languages and have complex dependency requirements. In such cases, it can be helpful to containerize your application using a service like Docker.

\section{Encouraging Collaborative Development} \label{CDHJS_sec:encouraging_collaborative_developement}

We now discuss ways a team may encourage collaborative development while touching on a few best practices. As discussed earlier, collaborative development promotes greater community engagement, ecosystem integration, and software longevity.

The authors have found the Git version control system to be an invaluable for software development. Git hosts such as GitHub or Bitbucket may offer teams additional features such as tracking issues, managing discussion threads, and setting up automated workflows for jobs such as testing and documentation compilation.

Accessibility is key to community engagment. It is paramount that your package be easy to install, well documented, and tested regularly. Aside from static communications, a team should also be engaged in addressing users bugs and be attentive to collaborating with proposed code changes.

It is also important for a development team to make a clear path for collaborators to contributors to the software. Templates for issues and pull requests are a good place to start. Contributors should also be encouraged to write robust tests for their updates and highlight their new features in a demo for greater accessibility.

\section{Example Collaboration with UMBridge and QMCPy} \label{CDHJS_sec:example_collaboration_umbridge}

This section discusses a collaboration between the UM-Bridge (the UQ and Model Bridge) \AGSComment{CITE} and QMCPy (the Quasi-Monte Carlo Python library) \cite{QMCPy2020a} softwares. The UM-Bridge documentation describes its' mission is to, ``provide a unified interface for numerical models that is accessible from virtually any programming language or framework. It is primarily intended for coupling advanced models (e.g. simulations of complex physical processes) to advanced statistics or optimization methods.'' QMCPy is a high level framework for combining QMC components in a compatible and consistent manner. The collaboration between these two packages focused on making the UQ methods of QMCPy compatible with the abstract model representations from UM-Bridge. Specifically, UM-Bridge models are made compatible with the QMCPy framework through an integrand wrapper for seamless compatibility with a variety of existing point generators, transformations, and stopping criterion already available in QMCPy.

To exemplify the integration, we focus on quantifying uncertainty propagation of material properties of a cantilevered beam. It is assumed the beam is split into $3$ regions of random stiffness dependent on uncertain material properties. Given a sample of $3$ stiffness values, the UM-Bridge model provides the displacement at $31$ equidistant nodes along the beam. Our task is to quantify the uncertainty in displacement at each of these $31$ locations along the beam.

A fully coded example of this problem is available at \url{https://github.com/QMCSoftware/QMCSoftware/blob/master/demos/umbridge.ipynb}. At a high level, one begins by running the UM-Bridge model in a Docker container. A model is then initialized in the UM-Bridge Python client which is then provided to QMCPy alongside a low discrepancy point generator and distribution governing the $3$ beam stiffness values. QMCPy then performs adaptive QMC cubature to simultaneously approximate the expected displacement at the $31$ locations of interest. When the cubature method queries the model, the QMCPy wrapper around UM-Bridge model sends requests to the Docker UM-Bridge model in parallel. The load balancing provided by UM-Bridge may be utilized to evaluate the model in parallel, a potentially advantageous feature for models which are costly to evaluate. Figure \ref{fig:umbridge_muq} depicts the $31$ approximate expected displacement values subject to uniform stiffness.

\begin{figure}
    \centering
    \includegraphics[height=4cm]{umbridge_muq.png}
    \caption{QMCPy approximate expected displacement at $31$ locations subject to random uniform stiffness. }
    \label{fig:umbridge_muq}
\end{figure}

\section*{TODO}
\begin{itemize}
    \item Flesh out Section \ref{CDHJS_sec:encouraging_collaborative_developement}
    \item QMC Software Architecture section: better way then description of components and list of softwares?
    \item For Section \ref{CDHJS_sec:tenets_of_great_software}, the slides also include
    \begin{itemize}
        \item  Complete---contain the components or  easily access components in other libraries to solve real, complex problems
        \item Current---include the latest and best algorithms
    \end{itemize}
    which I think fall under the umbrella of software being \emph{integrated} with the community.
    \item update QMCPy citation \cite{QMCPy2020a}
    \item figures?
    \item I have left out or been breif about material from the following slides: QMCPy + FEniCS/Dolfin,  Building a Developer Team for Your Library
\end{itemize}



Developing software to implement such enhanced MC strategies poses a number of challenges. First, a development team must determine the value of the software to the users. We discuss why great (Q)MC software in necessary in Sect.\ \ref{CDHJS_sec:why_we_need_software}. Second, a team must determine high level objectives for the software; the tenets of great software are described in Sect.\ \ref{CDHJS_sec:tenets_of_great_software}. Third, an architecture for the  (Q)MC software should be determined. We propose a modularization of the (Q)MC pipeline in Sect.\ \ref{CDHJS_sec:qmc_software_architecture}. Next, a team must choose which programming languages, hardware environments, and distribution platforms they wish to support. We discuss the nuance and challenges in these decisions in Sect.\ \ref{CDHJS_sec:language_library_environment}. Finally, a project which hopes to stand the test of time must draw attention and support from the broader (Q)MC community. To this end, we encourage collaborative community development and describe its' best practices in  Sect.\ \ref{CDHJS_sec:encouraging_collaborative_developement}.